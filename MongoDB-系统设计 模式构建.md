# MongoDB 系统设计 模式构建

## 一、背景

应用程序构造模式（schema）

大多数性能问题都可以追溯到糟糕的设计模式。

数据库设计考虑因素：

1. 读写操作哪个多；
2. 数据库读取时，需要哪些数据放在一起；
3. 哪些性能因素需要考虑；
4. 文档/单单条记录
   * 文档有多大
   * 文档以后会变成多大
5. 预计数据会如何增长和扩展；

MongoDB使用文档数据模型。此模型具有内在的灵活性，允许数据模型支持你的应用程序需求。灵活性也可能导致模式比它们应有样子的更复杂。在考虑模式设计时，我们应该考虑`性能`、`可伸缩性`和`简单性`。



## 二、模式构建

MongoDB中常见的十二种设计方式（Schema Design Patterns）

![image-20231207132851916](图片/image-20231207132851916.png)

> catalog 目录



### 1.多态模式

当集合中的所有文档都具有**相似但不相同的结构**时，我们将其称为多态模式。如前所述，当我们希望从单个集合中访问（查询）信息时，多态模式非常有用。根据我们要运行的查询将文档分组在一起（而不是将其分散在多个表或集合中）有助于提高性能。

**使用情景**

当文档具有更多的相似性而不是差异性时，就会使用多态模式。

**情景举例**

- 单一视图应用程序
- 内容管理
- 移动应用程序
- 产品目录

多态模式提供了一个易于实现的设计，允许在单个集合中进行查询



运动员例子：

![image-20231207143340930](图片/image-20231207143340930.png)

![image-20231207143430496](图片/image-20231207143430496.png)



### 2.属性模式

出于性能原因考虑，为了优化搜索我们可能需要许多索引以照顾到所有子集。创建所有这些索引可能会降低性能。属性模式为这种情况提供了一个很好的解决方案。

目的：多个索引->少数几个索引

假设现在有一个关于电影的集合。其中所有文档中可能都有类似的字段：标题、导演、制片人、演员等等。假如我们希望在上映日期这个字段进行搜索，这时面临的挑战是“哪个上映日期”？在不同的国家，电影通常在不同的日期上映。

~~~ json
{
    title: "Star Wars",
    director: "George Lucas",
    ...
    release_US: ISODate("1977-05-20T01:00:00+01:00"),
    release_France: ISODate("1977-10-19T01:00:00+01:00"),
    release_Italy: ISODate("1977-10-20T01:00:00+01:00"),
    release_UK: ISODate("1977-12-27T01:00:00+01:00"),
    ...
}
~~~

搜索上映日期需要同时查看多个字段。为了快速进行搜索，我们需要在电影集合中使用多个索引：

~~~ json
{release_US: 1}
{release_France: 1}
{release_Italy: 1}
...
~~~

使用属性模式，我们可以将此信息移至数组中并减少对索引需求。我们将这些信息转换成一个包含键值对的数组：

~~~ json
{
    title: "Star Wars",
    director: "George Lucas",
    …
    releases: [
        {
        location: "USA",
        date: ISODate("1977-05-20T01:00:00+01:00")
        },
        {
        location: "France",
        date: ISODate("1977-10-19T01:00:00+01:00")
        },
        {
        location: "Italy",
        date: ISODate("1977-10-20T01:00:00+01:00")
        },
        {
        location: "UK",
        date: ISODate("1977-12-27T01:00:00+01:00")
        },
        … 
    ],
    … 
}
~~~

通过在数组中的元素上创建一个这样的索引，索引变得更易于管理：

`{ “releases.location”: 1, “releases.date”: 1}`



**使用情景**

属性模式针对每个文档中许多类似字段提供了更简单的文档索引。通过将这个数据子集移动到一个键值子文档中，我们可以使用不确定的字段名，为信息添加额外的限定符，并更清楚地说明原始字段和值的关系。当我们使用属性模式时，由于需要的索引更少，查询变得更简单更快。

**情景举例**

- 我们有一些大文档，它们有很多相似的字段，而这些字段的一个子集具有共同的特征，我们希望对该子集字段进行排序或查询；
- 我们需要排序的字段只能在一小部分文档中找到；
- 上述两个条件均满足。



### 3.桶模式

这种模式在处理物联网（IOT）、实时分析或通用时间序列数据时特别有效。通过将数据放在一起，我们可以更容易地将数据组织成特定的组，提高发现历史趋势或提供未来预测的能力，同时还能对存储进行优化。

***

随着数据在一段时间内持续流入（时间序列数据），我们可能倾向于将每个测量值存储在自己的文档中。然而，这种倾向是一种非常偏向于关系型数据处理的方式。如果我们有一个传感器每分钟测量温度并将其保存到数据库中，我们的数据流可能看起来像这样：

~~~ json
{
   sensor_id: 12345,
   timestamp: ISODate("2019-01-31T10:00:00.000Z"),
   temperature: 40
}

{
   sensor_id: 12345,
   timestamp: ISODate("2019-01-31T10:01:00.000Z"),
   temperature: 40
}

{
   sensor_id: 12345,
   timestamp: ISODate("2019-01-31T10:02:00.000Z"),
   temperature: 41
}
~~~

使用桶模式：

~~~ json
{
    sensor_id: 12345,
    start_date: ISODate("2019-01-31T10:00:00.000Z"),
    end_date: ISODate("2019-01-31T10:59:59.000Z"),
    measurements: [
       {
       timestamp: ISODate("2019-01-31T10:00:00.000Z"),
       temperature: 40
       },
       {
       timestamp: ISODate("2019-01-31T10:01:00.000Z"),
       temperature: 40
       },
       … 
       {
       timestamp: ISODate("2019-01-31T10:42:00.000Z"),
       temperature: 42
       }
    ],
   transaction_count: 42,
   sum_temperature: 2413
}
~~~

特点：适合随时间增长的数据流，且不常访问的那种，比方说类似于运行日志类的，和需要归档的数据



**使用情景**

**处理时间序列数据时，在MongoDB中使用桶模式是一个很好的选择**。**它减少了集合中的文档总数，提高了索引性能，并且通过预聚合简化了数据访问**。



### 4.异常值模式



**应用情景**

异常值模式所要**解决的问题是防止以少量文档或查询来确定应用程序的解决方案，尤其是当该解决方案对大多数用例来说不是最佳的时候**。我们可以利用MongoDB的灵活数据模型在文档中添加一个字段来将其标记为异常值。然后在应用程序内部，我们对异常值的处理会略有不同。通过为典型的文档或查询定制模式，应用程序的性能将会针对那些正常的用例进行优化，而那些异常值仍将得到处理。





### 5.计算模式



### 6.子集模式



### 7.扩展引用模式

适合重复引用的情景，减少join的次数，从而提高性能。



### 8.近似值模式

不需要精确数字的情景，比如说人口：不是人口一变就写入，而是通过一个阈值触发写入（人数增长/减少超过一百人再写入）



### 9.树形模式



### 10.预分配模式



### 11.文档版本控制模式



### 12.模式版本控制模式











## 三、总结



##　四、参考资料

### 相关博客：

本文主要参考资料：https://pdai.tech/md/db/nosql-mongo/mongo-y-doc.html

https://docs.mongoing.com/shu-ju-mo-xing/data-model-design

### MongoDB官网使用场景资料：

https://www.mongodb.com/solutions/use-cases